// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_MATCH_OP_TYPE: i8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_MATCH_OP_TYPE: i8 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MATCH_OP_TYPE: [MatchOpType; 4] = [
    MatchOpType::Equal,
    MatchOpType::NotEqual,
    MatchOpType::RegexEqual,
    MatchOpType::RegexNotEqual,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MatchOpType(pub i8);
#[allow(non_upper_case_globals)]
impl MatchOpType {
    pub const Equal: Self = Self(0);
    pub const NotEqual: Self = Self(1);
    pub const RegexEqual: Self = Self(2);
    pub const RegexNotEqual: Self = Self(3);

    pub const ENUM_MIN: i8 = 0;
    pub const ENUM_MAX: i8 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::Equal,
        Self::NotEqual,
        Self::RegexEqual,
        Self::RegexNotEqual,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Equal => Some("Equal"),
            Self::NotEqual => Some("NotEqual"),
            Self::RegexEqual => Some("RegexEqual"),
            Self::RegexNotEqual => Some("RegexNotEqual"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for MatchOpType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for MatchOpType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for MatchOpType {
    type Output = MatchOpType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MatchOpType {
    type Scalar = i8;
    #[inline]
    fn to_little_endian(self) -> i8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i8) -> Self {
        let b = i8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for MatchOpType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for MatchOpType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_MATCHERS_CONDITION: i8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_MATCHERS_CONDITION: i8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MATCHERS_CONDITION: [MatchersCondition; 2] =
    [MatchersCondition::And, MatchersCondition::Or];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MatchersCondition(pub i8);
#[allow(non_upper_case_globals)]
impl MatchersCondition {
    pub const And: Self = Self(0);
    pub const Or: Self = Self(1);

    pub const ENUM_MIN: i8 = 0;
    pub const ENUM_MAX: i8 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::And, Self::Or];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::And => Some("And"),
            Self::Or => Some("Or"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for MatchersCondition {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for MatchersCondition {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for MatchersCondition {
    type Output = MatchersCondition;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MatchersCondition {
    type Scalar = i8;
    #[inline]
    fn to_little_endian(self) -> i8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i8) -> Self {
        let b = i8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for MatchersCondition {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for MatchersCondition {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_AGGREGATION_TYPE: i8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_AGGREGATION_TYPE: i8 = 11;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_AGGREGATION_TYPE: [AggregationType; 12] = [
    AggregationType::Sum,
    AggregationType::Avg,
    AggregationType::Min,
    AggregationType::Max,
    AggregationType::First,
    AggregationType::Last,
    AggregationType::Count,
    AggregationType::Range,
    AggregationType::StdS,
    AggregationType::StdP,
    AggregationType::VarS,
    AggregationType::VarP,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AggregationType(pub i8);
#[allow(non_upper_case_globals)]
impl AggregationType {
    pub const Sum: Self = Self(0);
    pub const Avg: Self = Self(1);
    pub const Min: Self = Self(2);
    pub const Max: Self = Self(3);
    pub const First: Self = Self(4);
    pub const Last: Self = Self(5);
    pub const Count: Self = Self(6);
    pub const Range: Self = Self(7);
    pub const StdS: Self = Self(8);
    pub const StdP: Self = Self(9);
    pub const VarS: Self = Self(10);
    pub const VarP: Self = Self(11);

    pub const ENUM_MIN: i8 = 0;
    pub const ENUM_MAX: i8 = 11;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::Sum,
        Self::Avg,
        Self::Min,
        Self::Max,
        Self::First,
        Self::Last,
        Self::Count,
        Self::Range,
        Self::StdS,
        Self::StdP,
        Self::VarS,
        Self::VarP,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Sum => Some("Sum"),
            Self::Avg => Some("Avg"),
            Self::Min => Some("Min"),
            Self::Max => Some("Max"),
            Self::First => Some("First"),
            Self::Last => Some("Last"),
            Self::Count => Some("Count"),
            Self::Range => Some("Range"),
            Self::StdS => Some("StdS"),
            Self::StdP => Some("StdP"),
            Self::VarS => Some("VarS"),
            Self::VarP => Some("VarP"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for AggregationType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for AggregationType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for AggregationType {
    type Output = AggregationType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AggregationType {
    type Scalar = i8;
    #[inline]
    fn to_little_endian(self) -> i8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i8) -> Self {
        let b = i8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for AggregationType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for AggregationType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_BUCKET_TIMESTAMP_TYPE: i8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_BUCKET_TIMESTAMP_TYPE: i8 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BUCKET_TIMESTAMP_TYPE: [BucketTimestampType; 3] = [
    BucketTimestampType::Start,
    BucketTimestampType::End,
    BucketTimestampType::Mid,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BucketTimestampType(pub i8);
#[allow(non_upper_case_globals)]
impl BucketTimestampType {
    pub const Start: Self = Self(0);
    pub const End: Self = Self(1);
    pub const Mid: Self = Self(2);

    pub const ENUM_MIN: i8 = 0;
    pub const ENUM_MAX: i8 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::Start, Self::End, Self::Mid];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Start => Some("Start"),
            Self::End => Some("End"),
            Self::Mid => Some("Mid"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for BucketTimestampType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for BucketTimestampType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for BucketTimestampType {
    type Output = BucketTimestampType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for BucketTimestampType {
    type Scalar = i8;
    #[inline]
    fn to_little_endian(self) -> i8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i8) -> Self {
        let b = i8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for BucketTimestampType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for BucketTimestampType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_BUCKET_ALIGNMENT_TYPE: i8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_BUCKET_ALIGNMENT_TYPE: i8 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BUCKET_ALIGNMENT_TYPE: [BucketAlignmentType; 4] = [
    BucketAlignmentType::Default,
    BucketAlignmentType::Start,
    BucketAlignmentType::End,
    BucketAlignmentType::Timestamp,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BucketAlignmentType(pub i8);
#[allow(non_upper_case_globals)]
impl BucketAlignmentType {
    pub const Default: Self = Self(0);
    pub const Start: Self = Self(1);
    pub const End: Self = Self(2);
    pub const Timestamp: Self = Self(3);

    pub const ENUM_MIN: i8 = 0;
    pub const ENUM_MAX: i8 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::Default, Self::Start, Self::End, Self::Timestamp];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Default => Some("Default"),
            Self::Start => Some("Start"),
            Self::End => Some("End"),
            Self::Timestamp => Some("Timestamp"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for BucketAlignmentType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for BucketAlignmentType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for BucketAlignmentType {
    type Output = BucketAlignmentType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for BucketAlignmentType {
    type Scalar = i8;
    #[inline]
    fn to_little_endian(self) -> i8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i8) -> Self {
        let b = i8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for BucketAlignmentType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for BucketAlignmentType {}
// struct ValueRangeFilter, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct ValueRangeFilter(pub [u8; 16]);
impl Default for ValueRangeFilter {
    fn default() -> Self {
        Self([0; 16])
    }
}
impl core::fmt::Debug for ValueRangeFilter {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ValueRangeFilter")
            .field("min", &self.min())
            .field("max", &self.max())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for ValueRangeFilter {}
impl<'a> flatbuffers::Follow<'a> for ValueRangeFilter {
    type Inner = &'a ValueRangeFilter;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a ValueRangeFilter>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a ValueRangeFilter {
    type Inner = &'a ValueRangeFilter;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<ValueRangeFilter>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for ValueRangeFilter {
    type Output = ValueRangeFilter;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(
            self as *const ValueRangeFilter as *const u8,
            <Self as flatbuffers::Push>::size(),
        );
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(8)
    }
}

impl<'a> flatbuffers::Verifiable for ValueRangeFilter {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> ValueRangeFilter {
    #[allow(clippy::too_many_arguments)]
    pub fn new(min: f64, max: f64) -> Self {
        let mut s = Self([0; 16]);
        s.set_min(min);
        s.set_max(max);
        s
    }

    pub fn min(&self) -> f64 {
        let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[0..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_min(&mut self, x: f64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[0..].as_mut_ptr(),
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn max(&self) -> f64 {
        let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[8..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_max(&mut self, x: f64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[8..].as_mut_ptr(),
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
        }
    }
}

pub enum MatcherOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Matcher<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Matcher<'a> {
    type Inner = Matcher<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Matcher<'a> {
    pub const VT_GROUP_ID: flatbuffers::VOffsetT = 4;
    pub const VT_LABEL: flatbuffers::VOffsetT = 6;
    pub const VT_OP: flatbuffers::VOffsetT = 8;
    pub const VT_VALUE: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Matcher { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args MatcherArgs<'args>,
    ) -> flatbuffers::WIPOffset<Matcher<'bldr>> {
        let mut builder = MatcherBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.label {
            builder.add_label(x);
        }
        builder.add_group_id(args.group_id);
        builder.add_op(args.op);
        builder.finish()
    }

    #[inline]
    pub fn group_id(&self) -> u16 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<u16>(Matcher::VT_GROUP_ID, Some(0)).unwrap() }
    }
    #[inline]
    pub fn label(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Matcher::VT_LABEL, None)
        }
    }
    #[inline]
    pub fn op(&self) -> MatchOpType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<MatchOpType>(Matcher::VT_OP, Some(MatchOpType::Equal))
                .unwrap()
        }
    }
    #[inline]
    pub fn value(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(Matcher::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for Matcher<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u16>("group_id", Self::VT_GROUP_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("label", Self::VT_LABEL, false)?
            .visit_field::<MatchOpType>("op", Self::VT_OP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct MatcherArgs<'a> {
    pub group_id: u16,
    pub label: Option<flatbuffers::WIPOffset<&'a str>>,
    pub op: MatchOpType,
    pub value: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for MatcherArgs<'a> {
    #[inline]
    fn default() -> Self {
        MatcherArgs {
            group_id: 0,
            label: None,
            op: MatchOpType::Equal,
            value: None,
        }
    }
}

pub struct MatcherBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MatcherBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_group_id(&mut self, group_id: u16) {
        self.fbb_
            .push_slot::<u16>(Matcher::VT_GROUP_ID, group_id, 0);
    }
    #[inline]
    pub fn add_label(&mut self, label: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Matcher::VT_LABEL, label);
    }
    #[inline]
    pub fn add_op(&mut self, op: MatchOpType) {
        self.fbb_
            .push_slot::<MatchOpType>(Matcher::VT_OP, op, MatchOpType::Equal);
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Matcher::VT_VALUE, value);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MatcherBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        MatcherBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Matcher<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Matcher<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Matcher");
        ds.field("group_id", &self.group_id());
        ds.field("label", &self.label());
        ds.field("op", &self.op());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum MatchersOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Matchers<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Matchers<'a> {
    type Inner = Matchers<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Matchers<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_CONDITION: flatbuffers::VOffsetT = 6;
    pub const VT_MATCHERS: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Matchers { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args MatchersArgs<'args>,
    ) -> flatbuffers::WIPOffset<Matchers<'bldr>> {
        let mut builder = MatchersBuilder::new(_fbb);
        if let Some(x) = args.matchers {
            builder.add_matchers(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_condition(args.condition);
        builder.finish()
    }

    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Matchers::VT_NAME, None)
        }
    }
    #[inline]
    pub fn condition(&self) -> MatchersCondition {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<MatchersCondition>(Matchers::VT_CONDITION, Some(MatchersCondition::And))
                .unwrap()
        }
    }
    #[inline]
    pub fn matchers(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Matcher<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Matcher>>,
            >>(Matchers::VT_MATCHERS, None)
        }
    }
}

impl flatbuffers::Verifiable for Matchers<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<MatchersCondition>("condition", Self::VT_CONDITION, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Matcher>>,
            >>("matchers", Self::VT_MATCHERS, false)?
            .finish();
        Ok(())
    }
}
pub struct MatchersArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub condition: MatchersCondition,
    pub matchers: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Matcher<'a>>>>,
    >,
}
impl<'a> Default for MatchersArgs<'a> {
    #[inline]
    fn default() -> Self {
        MatchersArgs {
            name: None,
            condition: MatchersCondition::And,
            matchers: None,
        }
    }
}

pub struct MatchersBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MatchersBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Matchers::VT_NAME, name);
    }
    #[inline]
    pub fn add_condition(&mut self, condition: MatchersCondition) {
        self.fbb_.push_slot::<MatchersCondition>(
            Matchers::VT_CONDITION,
            condition,
            MatchersCondition::And,
        );
    }
    #[inline]
    pub fn add_matchers(
        &mut self,
        matchers: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Matcher<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Matchers::VT_MATCHERS, matchers);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MatchersBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        MatchersBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Matchers<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Matchers<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Matchers");
        ds.field("name", &self.name());
        ds.field("condition", &self.condition());
        ds.field("matchers", &self.matchers());
        ds.finish()
    }
}
pub enum DateRangeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DateRange<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DateRange<'a> {
    type Inner = DateRange<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> DateRange<'a> {
    pub const VT_START: flatbuffers::VOffsetT = 4;
    pub const VT_END: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DateRange { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args DateRangeArgs,
    ) -> flatbuffers::WIPOffset<DateRange<'bldr>> {
        let mut builder = DateRangeBuilder::new(_fbb);
        builder.add_end(args.end);
        builder.add_start(args.start);
        builder.finish()
    }

    #[inline]
    pub fn start(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<i64>(DateRange::VT_START, Some(0)).unwrap() }
    }
    #[inline]
    pub fn end(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<i64>(DateRange::VT_END, Some(0)).unwrap() }
    }
}

impl flatbuffers::Verifiable for DateRange<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i64>("start", Self::VT_START, false)?
            .visit_field::<i64>("end", Self::VT_END, false)?
            .finish();
        Ok(())
    }
}
pub struct DateRangeArgs {
    pub start: i64,
    pub end: i64,
}
impl<'a> Default for DateRangeArgs {
    #[inline]
    fn default() -> Self {
        DateRangeArgs { start: 0, end: 0 }
    }
}

pub struct DateRangeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DateRangeBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_start(&mut self, start: i64) {
        self.fbb_.push_slot::<i64>(DateRange::VT_START, start, 0);
    }
    #[inline]
    pub fn add_end(&mut self, end: i64) {
        self.fbb_.push_slot::<i64>(DateRange::VT_END, end, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DateRangeBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        DateRangeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DateRange<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for DateRange<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("DateRange");
        ds.field("start", &self.start());
        ds.field("end", &self.end());
        ds.finish()
    }
}
pub enum MultiGetRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MultiGetRequest<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MultiGetRequest<'a> {
    type Inner = MultiGetRequest<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> MultiGetRequest<'a> {
    pub const VT_WITH_LABELS: flatbuffers::VOffsetT = 4;
    pub const VT_SELECTED_LABELS: flatbuffers::VOffsetT = 6;
    pub const VT_FILTERS: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MultiGetRequest { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args MultiGetRequestArgs<'args>,
    ) -> flatbuffers::WIPOffset<MultiGetRequest<'bldr>> {
        let mut builder = MultiGetRequestBuilder::new(_fbb);
        if let Some(x) = args.filters {
            builder.add_filters(x);
        }
        if let Some(x) = args.selected_labels {
            builder.add_selected_labels(x);
        }
        builder.add_with_labels(args.with_labels);
        builder.finish()
    }

    #[inline]
    pub fn with_labels(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(MultiGetRequest::VT_WITH_LABELS, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn selected_labels(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(MultiGetRequest::VT_SELECTED_LABELS, None)
        }
    }
    #[inline]
    pub fn filters(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Matchers<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Matchers>>,
            >>(MultiGetRequest::VT_FILTERS, None)
        }
    }
}

impl flatbuffers::Verifiable for MultiGetRequest<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("with_labels", Self::VT_WITH_LABELS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("selected_labels", Self::VT_SELECTED_LABELS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Matchers>>,
            >>("filters", Self::VT_FILTERS, false)?
            .finish();
        Ok(())
    }
}
pub struct MultiGetRequestArgs<'a> {
    pub with_labels: bool,
    pub selected_labels: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub filters: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Matchers<'a>>>>,
    >,
}
impl<'a> Default for MultiGetRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        MultiGetRequestArgs {
            with_labels: false,
            selected_labels: None,
            filters: None,
        }
    }
}

pub struct MultiGetRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MultiGetRequestBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_with_labels(&mut self, with_labels: bool) {
        self.fbb_
            .push_slot::<bool>(MultiGetRequest::VT_WITH_LABELS, with_labels, false);
    }
    #[inline]
    pub fn add_selected_labels(
        &mut self,
        selected_labels: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            MultiGetRequest::VT_SELECTED_LABELS,
            selected_labels,
        );
    }
    #[inline]
    pub fn add_filters(
        &mut self,
        filters: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Matchers<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(MultiGetRequest::VT_FILTERS, filters);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> MultiGetRequestBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        MultiGetRequestBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<MultiGetRequest<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for MultiGetRequest<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("MultiGetRequest");
        ds.field("with_labels", &self.with_labels());
        ds.field("selected_labels", &self.selected_labels());
        ds.field("filters", &self.filters());
        ds.finish()
    }
}
pub enum IndexQueryRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IndexQueryRequest<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IndexQueryRequest<'a> {
    type Inner = IndexQueryRequest<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> IndexQueryRequest<'a> {
    pub const VT_RANGE: flatbuffers::VOffsetT = 4;
    pub const VT_FILTERS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IndexQueryRequest { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args IndexQueryRequestArgs<'args>,
    ) -> flatbuffers::WIPOffset<IndexQueryRequest<'bldr>> {
        let mut builder = IndexQueryRequestBuilder::new(_fbb);
        if let Some(x) = args.filters {
            builder.add_filters(x);
        }
        if let Some(x) = args.range {
            builder.add_range(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn range(&self) -> Option<DateRange<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<DateRange>>(IndexQueryRequest::VT_RANGE, None)
        }
    }
    #[inline]
    pub fn filters(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Matchers<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Matchers>>,
            >>(IndexQueryRequest::VT_FILTERS, None)
        }
    }
}

impl flatbuffers::Verifiable for IndexQueryRequest<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<DateRange>>("range", Self::VT_RANGE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Matchers>>,
            >>("filters", Self::VT_FILTERS, false)?
            .finish();
        Ok(())
    }
}
pub struct IndexQueryRequestArgs<'a> {
    pub range: Option<flatbuffers::WIPOffset<DateRange<'a>>>,
    pub filters: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Matchers<'a>>>>,
    >,
}
impl<'a> Default for IndexQueryRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        IndexQueryRequestArgs {
            range: None,
            filters: None,
        }
    }
}

pub struct IndexQueryRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IndexQueryRequestBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_range(&mut self, range: flatbuffers::WIPOffset<DateRange<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<DateRange>>(
                IndexQueryRequest::VT_RANGE,
                range,
            );
    }
    #[inline]
    pub fn add_filters(
        &mut self,
        filters: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Matchers<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(IndexQueryRequest::VT_FILTERS, filters);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> IndexQueryRequestBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        IndexQueryRequestBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<IndexQueryRequest<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for IndexQueryRequest<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("IndexQueryRequest");
        ds.field("range", &self.range());
        ds.field("filters", &self.filters());
        ds.finish()
    }
}
pub enum LabelNamesRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LabelNamesRequest<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LabelNamesRequest<'a> {
    type Inner = LabelNamesRequest<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> LabelNamesRequest<'a> {
    pub const VT_RANGE: flatbuffers::VOffsetT = 4;
    pub const VT_FILTERS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        LabelNamesRequest { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args LabelNamesRequestArgs<'args>,
    ) -> flatbuffers::WIPOffset<LabelNamesRequest<'bldr>> {
        let mut builder = LabelNamesRequestBuilder::new(_fbb);
        if let Some(x) = args.filters {
            builder.add_filters(x);
        }
        if let Some(x) = args.range {
            builder.add_range(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn range(&self) -> Option<DateRange<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<DateRange>>(LabelNamesRequest::VT_RANGE, None)
        }
    }
    #[inline]
    pub fn filters(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Matchers<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Matchers>>,
            >>(LabelNamesRequest::VT_FILTERS, None)
        }
    }
}

impl flatbuffers::Verifiable for LabelNamesRequest<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<DateRange>>("range", Self::VT_RANGE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Matchers>>,
            >>("filters", Self::VT_FILTERS, false)?
            .finish();
        Ok(())
    }
}
pub struct LabelNamesRequestArgs<'a> {
    pub range: Option<flatbuffers::WIPOffset<DateRange<'a>>>,
    pub filters: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Matchers<'a>>>>,
    >,
}
impl<'a> Default for LabelNamesRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        LabelNamesRequestArgs {
            range: None,
            filters: None,
        }
    }
}

pub struct LabelNamesRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LabelNamesRequestBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_range(&mut self, range: flatbuffers::WIPOffset<DateRange<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<DateRange>>(
                LabelNamesRequest::VT_RANGE,
                range,
            );
    }
    #[inline]
    pub fn add_filters(
        &mut self,
        filters: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Matchers<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(LabelNamesRequest::VT_FILTERS, filters);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> LabelNamesRequestBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        LabelNamesRequestBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<LabelNamesRequest<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for LabelNamesRequest<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("LabelNamesRequest");
        ds.field("range", &self.range());
        ds.field("filters", &self.filters());
        ds.finish()
    }
}
pub enum LabelValuesRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LabelValuesRequest<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LabelValuesRequest<'a> {
    type Inner = LabelValuesRequest<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> LabelValuesRequest<'a> {
    pub const VT_LABEL: flatbuffers::VOffsetT = 4;
    pub const VT_RANGE: flatbuffers::VOffsetT = 6;
    pub const VT_FILTERS: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        LabelValuesRequest { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args LabelValuesRequestArgs<'args>,
    ) -> flatbuffers::WIPOffset<LabelValuesRequest<'bldr>> {
        let mut builder = LabelValuesRequestBuilder::new(_fbb);
        if let Some(x) = args.filters {
            builder.add_filters(x);
        }
        if let Some(x) = args.range {
            builder.add_range(x);
        }
        if let Some(x) = args.label {
            builder.add_label(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn label(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(LabelValuesRequest::VT_LABEL, None)
        }
    }
    #[inline]
    pub fn range(&self) -> Option<DateRange<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<DateRange>>(LabelValuesRequest::VT_RANGE, None)
        }
    }
    #[inline]
    pub fn filters(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Matchers<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Matchers>>,
            >>(LabelValuesRequest::VT_FILTERS, None)
        }
    }
}

impl flatbuffers::Verifiable for LabelValuesRequest<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("label", Self::VT_LABEL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<DateRange>>("range", Self::VT_RANGE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Matchers>>,
            >>("filters", Self::VT_FILTERS, false)?
            .finish();
        Ok(())
    }
}
pub struct LabelValuesRequestArgs<'a> {
    pub label: Option<flatbuffers::WIPOffset<&'a str>>,
    pub range: Option<flatbuffers::WIPOffset<DateRange<'a>>>,
    pub filters: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Matchers<'a>>>>,
    >,
}
impl<'a> Default for LabelValuesRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        LabelValuesRequestArgs {
            label: None,
            range: None,
            filters: None,
        }
    }
}

pub struct LabelValuesRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LabelValuesRequestBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_label(&mut self, label: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(LabelValuesRequest::VT_LABEL, label);
    }
    #[inline]
    pub fn add_range(&mut self, range: flatbuffers::WIPOffset<DateRange<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<DateRange>>(
                LabelValuesRequest::VT_RANGE,
                range,
            );
    }
    #[inline]
    pub fn add_filters(
        &mut self,
        filters: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Matchers<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(LabelValuesRequest::VT_FILTERS, filters);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> LabelValuesRequestBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        LabelValuesRequestBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<LabelValuesRequest<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for LabelValuesRequest<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("LabelValuesRequest");
        ds.field("label", &self.label());
        ds.field("range", &self.range());
        ds.field("filters", &self.filters());
        ds.finish()
    }
}
pub enum CardinalityRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CardinalityRequest<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CardinalityRequest<'a> {
    type Inner = CardinalityRequest<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> CardinalityRequest<'a> {
    pub const VT_RANGE: flatbuffers::VOffsetT = 4;
    pub const VT_FILTERS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CardinalityRequest { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args CardinalityRequestArgs<'args>,
    ) -> flatbuffers::WIPOffset<CardinalityRequest<'bldr>> {
        let mut builder = CardinalityRequestBuilder::new(_fbb);
        if let Some(x) = args.filters {
            builder.add_filters(x);
        }
        if let Some(x) = args.range {
            builder.add_range(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn range(&self) -> Option<DateRange<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<DateRange>>(CardinalityRequest::VT_RANGE, None)
        }
    }
    #[inline]
    pub fn filters(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Matchers<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Matchers>>,
            >>(CardinalityRequest::VT_FILTERS, None)
        }
    }
}

impl flatbuffers::Verifiable for CardinalityRequest<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<DateRange>>("range", Self::VT_RANGE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Matchers>>,
            >>("filters", Self::VT_FILTERS, false)?
            .finish();
        Ok(())
    }
}
pub struct CardinalityRequestArgs<'a> {
    pub range: Option<flatbuffers::WIPOffset<DateRange<'a>>>,
    pub filters: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Matchers<'a>>>>,
    >,
}
impl<'a> Default for CardinalityRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        CardinalityRequestArgs {
            range: None,
            filters: None,
        }
    }
}

pub struct CardinalityRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CardinalityRequestBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_range(&mut self, range: flatbuffers::WIPOffset<DateRange<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<DateRange>>(
                CardinalityRequest::VT_RANGE,
                range,
            );
    }
    #[inline]
    pub fn add_filters(
        &mut self,
        filters: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Matchers<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CardinalityRequest::VT_FILTERS, filters);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> CardinalityRequestBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        CardinalityRequestBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<CardinalityRequest<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for CardinalityRequest<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("CardinalityRequest");
        ds.field("range", &self.range());
        ds.field("filters", &self.filters());
        ds.finish()
    }
}
pub enum AggregationOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AggregationOptions<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AggregationOptions<'a> {
    type Inner = AggregationOptions<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> AggregationOptions<'a> {
    pub const VT_AGGREGATOR: flatbuffers::VOffsetT = 4;
    pub const VT_BUCKET_DURATION: flatbuffers::VOffsetT = 6;
    pub const VT_TIMESTAMP_OUTPUT: flatbuffers::VOffsetT = 8;
    pub const VT_BUCKET_ALIGNMENT: flatbuffers::VOffsetT = 10;
    pub const VT_ALIGNMENT_TIMESTAMP: flatbuffers::VOffsetT = 12;
    pub const VT_REPORT_EMPTY: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AggregationOptions { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args AggregationOptionsArgs,
    ) -> flatbuffers::WIPOffset<AggregationOptions<'bldr>> {
        let mut builder = AggregationOptionsBuilder::new(_fbb);
        builder.add_alignment_timestamp(args.alignment_timestamp);
        builder.add_bucket_duration(args.bucket_duration);
        builder.add_report_empty(args.report_empty);
        builder.add_bucket_alignment(args.bucket_alignment);
        builder.add_timestamp_output(args.timestamp_output);
        builder.add_aggregator(args.aggregator);
        builder.finish()
    }

    #[inline]
    pub fn aggregator(&self) -> AggregationType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<AggregationType>(
                    AggregationOptions::VT_AGGREGATOR,
                    Some(AggregationType::Sum),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn bucket_duration(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u64>(AggregationOptions::VT_BUCKET_DURATION, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn timestamp_output(&self) -> BucketTimestampType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<BucketTimestampType>(
                    AggregationOptions::VT_TIMESTAMP_OUTPUT,
                    Some(BucketTimestampType::Start),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn bucket_alignment(&self) -> BucketAlignmentType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<BucketAlignmentType>(
                    AggregationOptions::VT_BUCKET_ALIGNMENT,
                    Some(BucketAlignmentType::Default),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn alignment_timestamp(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(AggregationOptions::VT_ALIGNMENT_TIMESTAMP, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn report_empty(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(AggregationOptions::VT_REPORT_EMPTY, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for AggregationOptions<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<AggregationType>("aggregator", Self::VT_AGGREGATOR, false)?
            .visit_field::<u64>("bucket_duration", Self::VT_BUCKET_DURATION, false)?
            .visit_field::<BucketTimestampType>(
                "timestamp_output",
                Self::VT_TIMESTAMP_OUTPUT,
                false,
            )?
            .visit_field::<BucketAlignmentType>(
                "bucket_alignment",
                Self::VT_BUCKET_ALIGNMENT,
                false,
            )?
            .visit_field::<i64>("alignment_timestamp", Self::VT_ALIGNMENT_TIMESTAMP, false)?
            .visit_field::<bool>("report_empty", Self::VT_REPORT_EMPTY, false)?
            .finish();
        Ok(())
    }
}
pub struct AggregationOptionsArgs {
    pub aggregator: AggregationType,
    pub bucket_duration: u64,
    pub timestamp_output: BucketTimestampType,
    pub bucket_alignment: BucketAlignmentType,
    pub alignment_timestamp: i64,
    pub report_empty: bool,
}
impl<'a> Default for AggregationOptionsArgs {
    #[inline]
    fn default() -> Self {
        AggregationOptionsArgs {
            aggregator: AggregationType::Sum,
            bucket_duration: 0,
            timestamp_output: BucketTimestampType::Start,
            bucket_alignment: BucketAlignmentType::Default,
            alignment_timestamp: 0,
            report_empty: false,
        }
    }
}

pub struct AggregationOptionsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AggregationOptionsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_aggregator(&mut self, aggregator: AggregationType) {
        self.fbb_.push_slot::<AggregationType>(
            AggregationOptions::VT_AGGREGATOR,
            aggregator,
            AggregationType::Sum,
        );
    }
    #[inline]
    pub fn add_bucket_duration(&mut self, bucket_duration: u64) {
        self.fbb_
            .push_slot::<u64>(AggregationOptions::VT_BUCKET_DURATION, bucket_duration, 0);
    }
    #[inline]
    pub fn add_timestamp_output(&mut self, timestamp_output: BucketTimestampType) {
        self.fbb_.push_slot::<BucketTimestampType>(
            AggregationOptions::VT_TIMESTAMP_OUTPUT,
            timestamp_output,
            BucketTimestampType::Start,
        );
    }
    #[inline]
    pub fn add_bucket_alignment(&mut self, bucket_alignment: BucketAlignmentType) {
        self.fbb_.push_slot::<BucketAlignmentType>(
            AggregationOptions::VT_BUCKET_ALIGNMENT,
            bucket_alignment,
            BucketAlignmentType::Default,
        );
    }
    #[inline]
    pub fn add_alignment_timestamp(&mut self, alignment_timestamp: i64) {
        self.fbb_.push_slot::<i64>(
            AggregationOptions::VT_ALIGNMENT_TIMESTAMP,
            alignment_timestamp,
            0,
        );
    }
    #[inline]
    pub fn add_report_empty(&mut self, report_empty: bool) {
        self.fbb_
            .push_slot::<bool>(AggregationOptions::VT_REPORT_EMPTY, report_empty, false);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> AggregationOptionsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        AggregationOptionsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<AggregationOptions<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for AggregationOptions<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("AggregationOptions");
        ds.field("aggregator", &self.aggregator());
        ds.field("bucket_duration", &self.bucket_duration());
        ds.field("timestamp_output", &self.timestamp_output());
        ds.field("bucket_alignment", &self.bucket_alignment());
        ds.field("alignment_timestamp", &self.alignment_timestamp());
        ds.field("report_empty", &self.report_empty());
        ds.finish()
    }
}
pub enum GroupingOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GroupingOptions<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GroupingOptions<'a> {
    type Inner = GroupingOptions<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> GroupingOptions<'a> {
    pub const VT_GROUP_LABEL: flatbuffers::VOffsetT = 4;
    pub const VT_AGGREGATOR: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GroupingOptions { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args GroupingOptionsArgs<'args>,
    ) -> flatbuffers::WIPOffset<GroupingOptions<'bldr>> {
        let mut builder = GroupingOptionsBuilder::new(_fbb);
        if let Some(x) = args.group_label {
            builder.add_group_label(x);
        }
        builder.add_aggregator(args.aggregator);
        builder.finish()
    }

    #[inline]
    pub fn group_label(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(GroupingOptions::VT_GROUP_LABEL, None)
        }
    }
    #[inline]
    pub fn aggregator(&self) -> AggregationType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<AggregationType>(GroupingOptions::VT_AGGREGATOR, Some(AggregationType::Sum))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for GroupingOptions<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "group_label",
                Self::VT_GROUP_LABEL,
                false,
            )?
            .visit_field::<AggregationType>("aggregator", Self::VT_AGGREGATOR, false)?
            .finish();
        Ok(())
    }
}
pub struct GroupingOptionsArgs<'a> {
    pub group_label: Option<flatbuffers::WIPOffset<&'a str>>,
    pub aggregator: AggregationType,
}
impl<'a> Default for GroupingOptionsArgs<'a> {
    #[inline]
    fn default() -> Self {
        GroupingOptionsArgs {
            group_label: None,
            aggregator: AggregationType::Sum,
        }
    }
}

pub struct GroupingOptionsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GroupingOptionsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_group_label(&mut self, group_label: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            GroupingOptions::VT_GROUP_LABEL,
            group_label,
        );
    }
    #[inline]
    pub fn add_aggregator(&mut self, aggregator: AggregationType) {
        self.fbb_.push_slot::<AggregationType>(
            GroupingOptions::VT_AGGREGATOR,
            aggregator,
            AggregationType::Sum,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> GroupingOptionsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        GroupingOptionsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<GroupingOptions<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for GroupingOptions<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("GroupingOptions");
        ds.field("group_label", &self.group_label());
        ds.field("aggregator", &self.aggregator());
        ds.finish()
    }
}
pub enum RangeRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RangeRequest<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RangeRequest<'a> {
    type Inner = RangeRequest<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> RangeRequest<'a> {
    pub const VT_RANGE: flatbuffers::VOffsetT = 4;
    pub const VT_COUNT: flatbuffers::VOffsetT = 6;
    pub const VT_TIMESTAMP_FILTER: flatbuffers::VOffsetT = 8;
    pub const VT_VALUE_FILTER: flatbuffers::VOffsetT = 10;
    pub const VT_AGGREGATION: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RangeRequest { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args RangeRequestArgs<'args>,
    ) -> flatbuffers::WIPOffset<RangeRequest<'bldr>> {
        let mut builder = RangeRequestBuilder::new(_fbb);
        if let Some(x) = args.aggregation {
            builder.add_aggregation(x);
        }
        if let Some(x) = args.value_filter {
            builder.add_value_filter(x);
        }
        if let Some(x) = args.timestamp_filter {
            builder.add_timestamp_filter(x);
        }
        builder.add_count(args.count);
        if let Some(x) = args.range {
            builder.add_range(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn range(&self) -> Option<DateRange<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<DateRange>>(RangeRequest::VT_RANGE, None)
        }
    }
    #[inline]
    pub fn count(&self) -> u32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u32>(RangeRequest::VT_COUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn timestamp_filter(&self) -> Option<flatbuffers::Vector<'a, i64>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(
                    RangeRequest::VT_TIMESTAMP_FILTER,
                    None,
                )
        }
    }
    #[inline]
    pub fn value_filter(&self) -> Option<&'a ValueRangeFilter> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<ValueRangeFilter>(RangeRequest::VT_VALUE_FILTER, None)
        }
    }
    #[inline]
    pub fn aggregation(&self) -> Option<AggregationOptions<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<AggregationOptions>>(
                    RangeRequest::VT_AGGREGATION,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for RangeRequest<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<DateRange>>("range", Self::VT_RANGE, false)?
            .visit_field::<u32>("count", Self::VT_COUNT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>(
                "timestamp_filter",
                Self::VT_TIMESTAMP_FILTER,
                false,
            )?
            .visit_field::<ValueRangeFilter>("value_filter", Self::VT_VALUE_FILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<AggregationOptions>>(
                "aggregation",
                Self::VT_AGGREGATION,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct RangeRequestArgs<'a> {
    pub range: Option<flatbuffers::WIPOffset<DateRange<'a>>>,
    pub count: u32,
    pub timestamp_filter: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub value_filter: Option<&'a ValueRangeFilter>,
    pub aggregation: Option<flatbuffers::WIPOffset<AggregationOptions<'a>>>,
}
impl<'a> Default for RangeRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        RangeRequestArgs {
            range: None,
            count: 0,
            timestamp_filter: None,
            value_filter: None,
            aggregation: None,
        }
    }
}

pub struct RangeRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RangeRequestBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_range(&mut self, range: flatbuffers::WIPOffset<DateRange<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<DateRange>>(RangeRequest::VT_RANGE, range);
    }
    #[inline]
    pub fn add_count(&mut self, count: u32) {
        self.fbb_.push_slot::<u32>(RangeRequest::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn add_timestamp_filter(
        &mut self,
        timestamp_filter: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i64>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            RangeRequest::VT_TIMESTAMP_FILTER,
            timestamp_filter,
        );
    }
    #[inline]
    pub fn add_value_filter(&mut self, value_filter: &ValueRangeFilter) {
        self.fbb_
            .push_slot_always::<&ValueRangeFilter>(RangeRequest::VT_VALUE_FILTER, value_filter);
    }
    #[inline]
    pub fn add_aggregation(&mut self, aggregation: flatbuffers::WIPOffset<AggregationOptions<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<AggregationOptions>>(
                RangeRequest::VT_AGGREGATION,
                aggregation,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> RangeRequestBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        RangeRequestBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<RangeRequest<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for RangeRequest<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("RangeRequest");
        ds.field("range", &self.range());
        ds.field("count", &self.count());
        ds.field("timestamp_filter", &self.timestamp_filter());
        ds.field("value_filter", &self.value_filter());
        ds.field("aggregation", &self.aggregation());
        ds.finish()
    }
}
pub enum MultiRangeRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MultiRangeRequest<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MultiRangeRequest<'a> {
    type Inner = MultiRangeRequest<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> MultiRangeRequest<'a> {
    pub const VT_RANGE: flatbuffers::VOffsetT = 4;
    pub const VT_COUNT: flatbuffers::VOffsetT = 6;
    pub const VT_TIMESTAMP_FILTER: flatbuffers::VOffsetT = 8;
    pub const VT_VALUE_FILTER: flatbuffers::VOffsetT = 10;
    pub const VT_WITH_LABELS: flatbuffers::VOffsetT = 12;
    pub const VT_SELECTED_LABELS: flatbuffers::VOffsetT = 14;
    pub const VT_FILTERS: flatbuffers::VOffsetT = 16;
    pub const VT_AGGREGATION: flatbuffers::VOffsetT = 18;
    pub const VT_GROUPING: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MultiRangeRequest { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args MultiRangeRequestArgs<'args>,
    ) -> flatbuffers::WIPOffset<MultiRangeRequest<'bldr>> {
        let mut builder = MultiRangeRequestBuilder::new(_fbb);
        if let Some(x) = args.grouping {
            builder.add_grouping(x);
        }
        if let Some(x) = args.aggregation {
            builder.add_aggregation(x);
        }
        if let Some(x) = args.filters {
            builder.add_filters(x);
        }
        if let Some(x) = args.selected_labels {
            builder.add_selected_labels(x);
        }
        if let Some(x) = args.value_filter {
            builder.add_value_filter(x);
        }
        if let Some(x) = args.timestamp_filter {
            builder.add_timestamp_filter(x);
        }
        builder.add_count(args.count);
        if let Some(x) = args.range {
            builder.add_range(x);
        }
        builder.add_with_labels(args.with_labels);
        builder.finish()
    }

    #[inline]
    pub fn range(&self) -> Option<DateRange<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<DateRange>>(MultiRangeRequest::VT_RANGE, None)
        }
    }
    #[inline]
    pub fn count(&self) -> u32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u32>(MultiRangeRequest::VT_COUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn timestamp_filter(&self) -> Option<flatbuffers::Vector<'a, i64>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(
                    MultiRangeRequest::VT_TIMESTAMP_FILTER,
                    None,
                )
        }
    }
    #[inline]
    pub fn value_filter(&self) -> Option<&'a ValueRangeFilter> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<ValueRangeFilter>(MultiRangeRequest::VT_VALUE_FILTER, None)
        }
    }
    #[inline]
    pub fn with_labels(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(MultiRangeRequest::VT_WITH_LABELS, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn selected_labels(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(MultiRangeRequest::VT_SELECTED_LABELS, None)
        }
    }
    #[inline]
    pub fn filters(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Matchers<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Matchers>>,
            >>(MultiRangeRequest::VT_FILTERS, None)
        }
    }
    #[inline]
    pub fn aggregation(&self) -> Option<AggregationOptions<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<AggregationOptions>>(
                    MultiRangeRequest::VT_AGGREGATION,
                    None,
                )
        }
    }
    #[inline]
    pub fn grouping(&self) -> Option<GroupingOptions<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<GroupingOptions>>(
                    MultiRangeRequest::VT_GROUPING,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for MultiRangeRequest<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<DateRange>>("range", Self::VT_RANGE, false)?
            .visit_field::<u32>("count", Self::VT_COUNT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>(
                "timestamp_filter",
                Self::VT_TIMESTAMP_FILTER,
                false,
            )?
            .visit_field::<ValueRangeFilter>("value_filter", Self::VT_VALUE_FILTER, false)?
            .visit_field::<bool>("with_labels", Self::VT_WITH_LABELS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("selected_labels", Self::VT_SELECTED_LABELS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Matchers>>,
            >>("filters", Self::VT_FILTERS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<AggregationOptions>>(
                "aggregation",
                Self::VT_AGGREGATION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<GroupingOptions>>(
                "grouping",
                Self::VT_GROUPING,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct MultiRangeRequestArgs<'a> {
    pub range: Option<flatbuffers::WIPOffset<DateRange<'a>>>,
    pub count: u32,
    pub timestamp_filter: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub value_filter: Option<&'a ValueRangeFilter>,
    pub with_labels: bool,
    pub selected_labels: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub filters: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Matchers<'a>>>>,
    >,
    pub aggregation: Option<flatbuffers::WIPOffset<AggregationOptions<'a>>>,
    pub grouping: Option<flatbuffers::WIPOffset<GroupingOptions<'a>>>,
}
impl<'a> Default for MultiRangeRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        MultiRangeRequestArgs {
            range: None,
            count: 0,
            timestamp_filter: None,
            value_filter: None,
            with_labels: false,
            selected_labels: None,
            filters: None,
            aggregation: None,
            grouping: None,
        }
    }
}

pub struct MultiRangeRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MultiRangeRequestBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_range(&mut self, range: flatbuffers::WIPOffset<DateRange<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<DateRange>>(
                MultiRangeRequest::VT_RANGE,
                range,
            );
    }
    #[inline]
    pub fn add_count(&mut self, count: u32) {
        self.fbb_
            .push_slot::<u32>(MultiRangeRequest::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn add_timestamp_filter(
        &mut self,
        timestamp_filter: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i64>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            MultiRangeRequest::VT_TIMESTAMP_FILTER,
            timestamp_filter,
        );
    }
    #[inline]
    pub fn add_value_filter(&mut self, value_filter: &ValueRangeFilter) {
        self.fbb_.push_slot_always::<&ValueRangeFilter>(
            MultiRangeRequest::VT_VALUE_FILTER,
            value_filter,
        );
    }
    #[inline]
    pub fn add_with_labels(&mut self, with_labels: bool) {
        self.fbb_
            .push_slot::<bool>(MultiRangeRequest::VT_WITH_LABELS, with_labels, false);
    }
    #[inline]
    pub fn add_selected_labels(
        &mut self,
        selected_labels: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            MultiRangeRequest::VT_SELECTED_LABELS,
            selected_labels,
        );
    }
    #[inline]
    pub fn add_filters(
        &mut self,
        filters: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Matchers<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(MultiRangeRequest::VT_FILTERS, filters);
    }
    #[inline]
    pub fn add_aggregation(&mut self, aggregation: flatbuffers::WIPOffset<AggregationOptions<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<AggregationOptions>>(
                MultiRangeRequest::VT_AGGREGATION,
                aggregation,
            );
    }
    #[inline]
    pub fn add_grouping(&mut self, grouping: flatbuffers::WIPOffset<GroupingOptions<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<GroupingOptions>>(
                MultiRangeRequest::VT_GROUPING,
                grouping,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> MultiRangeRequestBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        MultiRangeRequestBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<MultiRangeRequest<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for MultiRangeRequest<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("MultiRangeRequest");
        ds.field("range", &self.range());
        ds.field("count", &self.count());
        ds.field("timestamp_filter", &self.timestamp_filter());
        ds.field("value_filter", &self.value_filter());
        ds.field("with_labels", &self.with_labels());
        ds.field("selected_labels", &self.selected_labels());
        ds.field("filters", &self.filters());
        ds.field("aggregation", &self.aggregation());
        ds.field("grouping", &self.grouping());
        ds.finish()
    }
}
pub enum MetadataRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MetadataRequest<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MetadataRequest<'a> {
    type Inner = MetadataRequest<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> MetadataRequest<'a> {
    pub const VT_RANGE: flatbuffers::VOffsetT = 4;
    pub const VT_FILTERS: flatbuffers::VOffsetT = 6;
    pub const VT_LIMIT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MetadataRequest { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args MetadataRequestArgs<'args>,
    ) -> flatbuffers::WIPOffset<MetadataRequest<'bldr>> {
        let mut builder = MetadataRequestBuilder::new(_fbb);
        builder.add_limit(args.limit);
        if let Some(x) = args.filters {
            builder.add_filters(x);
        }
        if let Some(x) = args.range {
            builder.add_range(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn range(&self) -> Option<DateRange<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<DateRange>>(MetadataRequest::VT_RANGE, None)
        }
    }
    #[inline]
    pub fn filters(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Matchers<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Matchers>>,
            >>(MetadataRequest::VT_FILTERS, None)
        }
    }
    #[inline]
    pub fn limit(&self) -> u32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u32>(MetadataRequest::VT_LIMIT, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for MetadataRequest<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<DateRange>>("range", Self::VT_RANGE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Matchers>>,
            >>("filters", Self::VT_FILTERS, false)?
            .visit_field::<u32>("limit", Self::VT_LIMIT, false)?
            .finish();
        Ok(())
    }
}
pub struct MetadataRequestArgs<'a> {
    pub range: Option<flatbuffers::WIPOffset<DateRange<'a>>>,
    pub filters: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Matchers<'a>>>>,
    >,
    pub limit: u32,
}
impl<'a> Default for MetadataRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        MetadataRequestArgs {
            range: None,
            filters: None,
            limit: 0,
        }
    }
}

pub struct MetadataRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MetadataRequestBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_range(&mut self, range: flatbuffers::WIPOffset<DateRange<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<DateRange>>(
                MetadataRequest::VT_RANGE,
                range,
            );
    }
    #[inline]
    pub fn add_filters(
        &mut self,
        filters: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Matchers<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(MetadataRequest::VT_FILTERS, filters);
    }
    #[inline]
    pub fn add_limit(&mut self, limit: u32) {
        self.fbb_
            .push_slot::<u32>(MetadataRequest::VT_LIMIT, limit, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> MetadataRequestBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        MetadataRequestBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<MetadataRequest<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for MetadataRequest<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("MetadataRequest");
        ds.field("range", &self.range());
        ds.field("filters", &self.filters());
        ds.field("limit", &self.limit());
        ds.finish()
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `RangeRequest`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_range_request_unchecked`.
pub fn root_as_range_request(buf: &[u8]) -> Result<RangeRequest, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<RangeRequest>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `RangeRequest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_range_request_unchecked`.
pub fn size_prefixed_root_as_range_request(
    buf: &[u8],
) -> Result<RangeRequest, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<RangeRequest>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `RangeRequest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_range_request_unchecked`.
pub fn root_as_range_request_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<RangeRequest<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<RangeRequest<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `RangeRequest` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_range_request_unchecked`.
pub fn size_prefixed_root_as_range_request_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<RangeRequest<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<RangeRequest<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a RangeRequest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `RangeRequest`.
pub unsafe fn root_as_range_request_unchecked(buf: &[u8]) -> RangeRequest {
    flatbuffers::root_unchecked::<RangeRequest>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed RangeRequest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `RangeRequest`.
pub unsafe fn size_prefixed_root_as_range_request_unchecked(buf: &[u8]) -> RangeRequest {
    flatbuffers::size_prefixed_root_unchecked::<RangeRequest>(buf)
}
#[inline]
pub fn finish_range_request_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<RangeRequest<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_range_request_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<RangeRequest<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
